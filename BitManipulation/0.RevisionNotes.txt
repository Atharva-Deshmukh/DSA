  ----------------------------------------Leetcode questions to revise-----------------------------------
- Q4
- Q13
- Q19

  --------------------------------------------Topics to revise--------------------------------------------
- 4. BK Algo
- 11. Set bits from 1-N Logic
- 14. Decimal to Binary
- 15. Binary to Decimal
- 17. Square of N
- 20. Logic for 1s complement
- 21. Logic for 2s complement
- 22. Divide two numbers using Bit Manipulation
- 23. Logic for power set (all input combinations)
- 25. all Observations + MEMORISE concept of buckets in single number
- 26. Technique to separate two numbers from their XOR
- 27. Revise logic
- 28. Revise logic

  --------------------------------------------CONCEPTS HERE ITSELF--------------------------------------------

  Sort array based on count of set bits in them, if count of set bits is same, then sort numbers by values
  
  // No need of map, directly write custom sort()
  function sortByBits(arr: number[]): number[] {
      let n = arr.length;
      if (n === 1) return arr;
    
      arr = arr.sort((a, b) => {
        if(bitCount_BK_Algo(a) === bitCount_BK_Algo(b)) return a - b;
        else return bitCount_BK_Algo(a) - bitCount_BK_Algo(b);
      });
      
      return arr;
  }

  create a mask of all 1s in the bit range of n (as per no of bits in n)
  say, n = 7 (0111) ==> mask = 1111

  let mask = 0;
  while(n) {
      mask = (mask << 1) | 1; 
      n = n >> 1;
  }

  XOR till N:
  if(n % 4 === 0) XOR till n = n itself
  if(n % 4 === 1) XOR till n = 1
  if(n % 4 === 2) XOR till n = n + 1
  if(n % 4 === 3) XOR till n = 0

  XOR in range [L-R] = XOR_1ton(L-1) ^ XOR_1ton(R);

  For query based XOR in range, use prefix[] to avoid duplicate calculation.

  MASK FROM [L-R]
    The bit mask that has set bits in the range [L, R] can be generated using:
    [((1 << (L-1)) - 1) ^ ((1 << R) - 1)]  

  When n is odd, no of bits in n === ((no of bits in n/2) + 1)
  ex: 7 - 3 | 9 - 2
      3 - 2 | 4 - 1

  When n is even, no of bits in n === no of bits in n/2
  ex: 6 - 2 | 8 - 1
      3 - 2 | 4 - 1

  EVEN-ODD:
  - check last bit --> return Boolean(n&1);

  NO OF BITS in n:
  - return (Math.floor(Math.log2(n)) + 1);

  CHECK FOR POWER OF 2:
  - has only 1 bit
  -  return ((n > 0) & (n & (n-1)) === 0);

  COUNT SET BITS: 
  - Revise full Q4
  - Recursion and BK 
  
  SET kth bit: (where k = 1st, 2nd i.e. absolute position)
  - return ((1 << (k - 1)) | n)  
  - OR used since 0 -> 1 and 1 -> 1

  TOGGLE kth bit: (where k = 1st, 2nd i.e. absolute position)
  - return ((1 << (k - 1)) ^ n)  
  - XOR used since 0 -> 1 and 1 -> 0

  REMOVE LAST SET BIT
  - return (n & (n - 1))  

  POSITION OF RIGHTMOST SET BIT
  - return Math.log2((n & (n - 1)) ^ n)  

  CLEAR kth bit
  - return (n & ~ (1 << (k - 1)))  

  THOUGHT PROCESS for getting highest power of 2 till N (from 1 - N)

        3 2 1 0
    9 - 1 0 0 1         pos of MSB of N = 4, highest power of 2 = 3 = pos - 1

        3 2 1 0
    5 - 0 1 0 1         pos of MSB of N = 3, highest power of 2 = 2 = pos - 1

        3 2 1 0
    3 - 0 0 1 1         pos of MSB of N = 2, highest power of 2 = 1 = pos - 1 

    highest pow of 2 from [1 to N] = (MSB pos of N - 1)

    NUMBER OF BITS TO FLIP TO CONVERT a to b
    - We need to flip the different bits only
    - return countSetBitsUsingBKAlgo(a ^ b)

    SWAP TWO NUMBERS USING XOR
      a = a ^ b: The XOR of a and b is stored in a.
      b = a ^ b: --> (a ^ b) ^ b --> a
      a = a ^ b: --> (a ^ b) ^ a --> b