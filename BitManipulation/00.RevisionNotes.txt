 --------------------------------------------CONCEPTS HERE ITSELF--------------------------------------------
 ------------------------------------------------------------------------------------------------------------
CHECK EVEN ODD:

            The LSB is set in case of Odd numbers

            (n & 1) === 0 ==> EVEN
            (n & 1) === 1 ==> ODD

            function checkEvenOdd(n: number): boolean {
                return Boolean(n&1);
            }

-------------------------------------------------------------------------------------------------------------
COUNT TOTAL BITS A NUMBER WILL TAKE (NOT SET BITS):

                0 -> 00 --> 0
                1 -> 01 --> 1
                2 -> 10 --> 1
                3 -> 11 --> 2
                4 -> 001 --> 1

                function countBits_Way1(n: number): number {
                    return (Math.floor(Math.log2(n)) + 1);
                }

------------------------------------------------------------------------------------------------------------
POWER OF 2: 
                It has a single bit only

                4 -->  0100
            4 - 1 -->  0011
          (4 & 3) -->  0000

                function powOfTwo(n: number): boolean {
                    if(n === 0) return false;
                    if(Math.abs(n) >= Math.pow(2, 31)) return false;
                    return ((n & (n-1)) === 0);
                }


------------------------------------------------------------------------------------------------------------
COUNT SET BITS:

                                Brian Kreigan Algorithm
                                -----------------------

                When we do (n & (n - 1)), rightmost set bit becomes unset
                BK Algo = Keep doing (n & (n - 1)) till number becomes 0 and count the times we run the loop
                That's the number of set bits

                function countSetBits2(n: number) {
                    var count = 0;
                    while (n > 0)
                    {
                        n &= (n - 1);
                        count++;
                    }
                    return count;
                }

COUNTING SET BITS FROM [0 - N]

                    There is one observation

0 --> 0000          6 --> 0110                
1 --> 0001          7 --> 0111
2 --> 0010          8 --> 1000
3 --> 0011          9 --> 1001
4 --> 0100         10 --> 1010
5 --> 0101         11 --> 1011

When n is even, no of bits in n === no of bits in n/2
ex: 6 - 2 | 8 - 1
    3 - 2 | 4 - 1

When n is odd, no of bits in n === ((no of bits in n/2) + 1)
ex: 7 - 3 | 9 - 2
    3 - 2 | 4 - 1

- we can keep storing the halves in a dp[]
- store basic counts like 0, 1 and 2 in dp[0, 1, 1], index = number itself
- start from 3 now, 

------------------------------------------------------------------------------------------------------------
  SET kth bit: (where k = 1st, 2nd i.e. absolute position)

  - return ((1 << (k - 1)) | n)  
  - OR used since 0 -> 1 and 1 -> 1
------------------------------------------------------------------------------------------------------------
  TOGGLE kth bit: (where k = 1st, 2nd i.e. absolute position)

  - return ((1 << (k - 1)) ^ n)  
  - XOR used since 0 -> 1 and 1 -> 0

  If k = 0-based, then 
  - return ((1 << k) ^ n)
------------------------------------------------------------------------------------------------------------
  REMOVE LAST SET BIT

  - return (n & (n - 1))  
------------------------------------------------------------------------------------------------------------
  POSITION OF RIGHTMOST SET BIT

  - return Math.log2((n & (n - 1)) ^ n)     --> 0-based indexing
    Log returns the position

 - return Math.log2(n ^ (n & (n - 1))) + 1; --> 1-based indexing
------------------------------------------------------------------------------------------------------------
  CLEAR kth bit

  - return (n & ~ (1 << (k - 1)))  
------------------------------------------------------------------------------------------------------------
  Sort array based on count of set bits in them, if count of set bits is same, then sort numbers by values
  
  // No need of map, directly write custom sort()
  function sortByBits(arr: number[]): number[] {
      let n = arr.length;
      if (n === 1) return arr;
    
      arr = arr.sort((a, b) => {
        if(bitCount_BK_Algo(a) === bitCount_BK_Algo(b)) return a - b;
        else return bitCount_BK_Algo(a) - bitCount_BK_Algo(b);
      });
      
      return arr;
  }

  create a mask of all 1s in the bit range of n (as per no of bits in n)
  say, n = 7 (0111) ==> mask = 1111

  let mask = 0;
  while(n) {
      mask = (mask << 1) | 1; 
      n = n >> 1;
  }

  XOR till N:
  if(n % 4 === 0) XOR till n = n itself
  if(n % 4 === 1) XOR till n = 1
  if(n % 4 === 2) XOR till n = n + 1
  if(n % 4 === 3) XOR till n = 0

  XOR in range [L-R] = XOR_1ton(L-1) ^ XOR_1ton(R);

  For query based XOR in range, use prefix[] to avoid duplicate calculation.

  MASK FROM [L-R]
    The bit mask that has set bits in the range [L, R] can be generated using:
    [((1 << (L-1)) - 1) ^ ((1 << R) - 1)]   

  THOUGHT PROCESS for getting highest power of 2 till N (from 1 - N)

        3 2 1 0
    9 - 1 0 0 1         pos of MSB of N = 4, highest power of 2 = 3 = pos - 1

        3 2 1 0
    5 - 0 1 0 1         pos of MSB of N = 3, highest power of 2 = 2 = pos - 1

        3 2 1 0
    3 - 0 0 1 1         pos of MSB of N = 2, highest power of 2 = 1 = pos - 1 

    highest pow of 2 from [1 to N] = ((MSB pos of N) - 1)

    NUMBER OF BITS TO FLIP TO CONVERT a to b
    - We need to flip the different bits only
    - return countSetBitsUsingBKAlgo(a ^ b)

    SWAP TWO NUMBERS USING XOR
      a = a ^ b: The XOR of a and b is stored in a.
      b = a ^ b: --> (a ^ b) ^ b --> a
      a = a ^ b: --> (a ^ b) ^ a --> b


Single Number - 2: MEMORISE THIS BUCKET TECHNIQUE
Input: nums = [2,2,3,2]             Output: 3
Input: nums = [0,1,0,1,0,1,99]      Output: 99

function singleNumberBucketSolution(a: number[]): number {
    let ones: number = 0;
    let twos: number = 0;

    a.forEach((num) => {
        // add it to ones if it is not in twos, for the next element in the array, if the element is same 
        // this ones line will automatically remove the element from ones since ones ^ ones = 0 and 0 & 0 = 0
        ones = (num ^ ones) & (~twos);

        // add it to twos if it is there in ones, but here we already removed it from ones, so this line works fine
        twos = (num ^ twos) & (~ones);
    });

    return ones;
}

