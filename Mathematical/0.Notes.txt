
////////////////////////////////////// QUESTIONS TO FULLY REVISE //////////////////////////////////////////////

REVISE DMAS using arithmetic

////////////////////////////////////// CONCEPTS //////////////////////////////////////////////////////////////

KNOW THAT: sum of odd numbers is a perfect square
For 1,3,5,7,9,11
1 + 3 = 4                      Iterations = 2 = sqrt(4)
1 + 3 + 5 = 9                  Iterations = 3 = sqrt(9)
1 + 3 + 5 + 7 = 16 and so on,

-------------------------------------------------------------------------------------------------------------
POWER EXPONENTIATION TRICK: 

Logic:
- let ans = 1;
- Iterate till currentPower = 0

- if(currentPower === odd) 
  ans = ans * currentBase
  currentPower = currentPower - 1

- if(currentPower === even) 
  currentPower = currentPower / 2
  currentBase = (currentBase * currentBase) = (currentBase ^ 2)
  

Dry run:
- let ans = 1, n = 2, x = 21

while (x > 0)

- when power is ODD, separate only one number and do power-1 
  pow(2,21) = 2 *  pow(2,20)
  multiply this to ans, ans = ans * 2

- when power is EVEN, do n = n*n and power = power/2
  pow(2,20) =  pow(2^2,20/2) = pow(4,10)  

- now, x is EVEN, 
  pow(4,10) = pow(4^2,10/2) = pow(16,5)

- now, x is ODD
  pow(16,5) = 16 * pow(16,4)
  ans = ans * 16

- now, x is EVEN
  pow(16,4) = pow(16^2,4/2) = pow(256,2)

- now, x is EVEN
  pow(256,2) = pow(256^2,2/2) = pow(65536,1)

- now, x is ODD
  pow(65536,1) = 65536 * pow(65536,0) = 65536 * 1 = 65536
  ans = ans * 65536

  return ans   

------------------------------------------------------------------------------------------------
TRICK to get unique prime factors:
  - exhaust all 2s and store in SET 
  - since all 2s are exhausted, we now get odd number, odd numbers differ by 2, so (i += 2)
  - then exhaust remaining factors and keep pushing them in SET.


------------------------------------------------------------------------------------------------
TRICK to get all prime factors:

  WAY-1:
  - use unique prime factors method, just use normal array instead of SET.

  WAY-2:
  - We can use smallest prime factors to get prime factors
    SPF(20) = 2   now 20/2 = 10
    SPF(10) = 2   now 10/2 = 5
    SPF(5) = 5    now 5/5 = 1  

    STOP at 1 !!
    
    this iterations take max O(logN) which happens when a number is power of 2
    for power of 2, we need max iterations since every time I need to divide by 2  

                      How to get spf[]? => adapt sieve approach

  -  let spf[n+1] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                     0  1  2  3  4  5  6  7  8  9  10
  - start from (2 - sqrt(n)), and for every multiple of 2, replace it with 2, similar for 3
  - basically, whenever spf[i] > i, replace it with i

  -  replace 2's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 9, 2]
                              0  1  2  3  4  5  6  7  8  9  10
  -  replace 3's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2]
                              0  1  2  3  4  5  6  7  8  9  10
  -  replace 5's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2]
                              0  1  2  3  4  5  6  7  8  9  10

  - replace only if spf[i] is untouched, to be untouched, spf[i] = i, very initial state of the array
------------------------------------------------------------------------------------------------

TRICK for getting all factors:
- Prime factors occur in pairs

  Input : n = 10       Output: 1 2 5 10
  Input:  n = 100      Output: 1 2 4 5 10 20 25 50 100

  WAY-1:
  - Iterate from 1 to sqrt(n), print i and then (n / i)
    But this way, we will get zigzag pattern: 1, 100, 2, 20, 4, 25, 5, 20

  WAY-2: 
  - Iterate first from 1 to sqr(n), if((n % i) === 0) print(i);
  - Now iterate from sqrt(n) to 1, if (i !== sqrt(n)) to avoid printing sqrt twice in case of perfect square
    if((n%/ i) === 0) print(n / i);

    TC: O(sqrt(n)) + O(sqrt(n)) = O(sqrt(n))
    SC: O(1)
------------------------------------------------------------------------------------------------
  
FACTORIAL of very large number:
- needed since factorial of 100 has 158 digits

WAY-1: use BigInt(), but its language specific (1n or BigInt(1))
WAY-2: Use array to store the result (language independent)

let n = 5, let us have an array res = [];  size = 0

Now, fill with 1 initially since 1 will be there in every factorial and make size = 1
res = [1] size = 1 carry = 0

multiply all elements of array with 2 (school mathematics). 
since array needs to be modified now.
res = [2]  // 2 * 1
size = 1
carry = 0 

multiply all elements of array with 3 (school mathematics). 
since array needs to be modified now.
res = [6]  // 3 * 2
size = 1
carry = 0 

Note that above, we multiply all array elements (equal to size)
multiply all elements of array with 4 (school mathematics). 
6 * 4 = 24, arr[0] = 4 and carry = 2, push carry in array and now size = 2
res = [4, 2] 
size = 2
carry = 2 


