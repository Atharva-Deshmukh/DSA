
////////////////////////////////////// QUESTIONS TO FULLY REVISE //////////////////////////////////////////////
- Q.5
- Q.7
- Q.8
- Q.9
- Q.10
- Q.11  2 questions are there
- Q.12  NEW way to print zigzag number pattern
- Q.13  SimpleLogic but great implementation

////////////////////////////////////// CONCEPTS //////////////////////////////////////////////////////////////

KNOW THAT: sum of odd numbers is a perfect square
For 1,3,5,7,9,11
1 + 3 = 4                      Iterations = 2 = sqrt(4)
1 + 3 + 5 = 9                  Iterations = 3 = sqrt(9)
1 + 3 + 5 + 7 = 16 and so on,

-------------------------------------------------------------------------------------------------------------
POWER EXPONENTIATION TRICK:

Logic:
- let ans = 1;
- Iterate till currentPower = 0

- if(currentPower === odd) 
  ans = ans * currentBase
  currentPower = currentPower - 1

- if(currentPower === even) 
  currentPower = currentPower / 2
  currentBase = (currentBase * currentBase) = (currentBase ^ 2)
  

Dry run:
- let ans = 1, n = 2, x = 21

while (x > 0)

- when power is ODD, separate only one number and do power-1 
  pow(2,21) = 2 *  pow(2,20)
  multiply this to ans, ans = ans * 2

- when power is EVEN, do n = n*n and power = power/2
  pow(2,20) =  pow(2^2,20/2) = pow(4,10)  

- now, x is EVEN, 
  pow(4,10) = pow(4^2,10/2) = pow(16,5)

- now, x is ODD
  pow(16,5) = 16 * pow(16,4)
  ans = ans * 16

- now, x is EVEN
  pow(16,4) = pow(16^2,4/2) = pow(256,2)

- now, x is EVEN
  pow(256,2) = pow(256^2,2/2) = pow(65536,1)

- now, x is ODD
  pow(65536,1) = 65536 * pow(65536,0) = 65536 * 1 = 65536
  ans = ans * 65536

  return ans   

------------------------------------------------------------------------------------------------
TRICK to get unique prime factors:
  - exhaust all 2s and store in SET 
  - since all 2s are exhausted, we now get odd number, odd numbers differ by 2, so (i += 2)
  - then exhaust remaining factors and keep pushing them in SET.

------------------------------------------------------------------------------------------------
TRICK to get all prime factors:

  WAY-1:
  - use unique prime factors method, just use normal array instead of SET.

  WAY-2:
  - We can use smallest prime factors to get prime factors
    SPF(20) = 2   now 20/2 = 10
    SPF(10) = 2   now 10/2 = 5
    SPF(5) = 5    now 5/5 = 1  

    STOP at 1 !!
    
    this iterations take max O(logN) which happens when a number is power of 2
    for power of 2, we need max iterations since every time I need to divide by 2  

                      How to get spf[]? => adapt sieve approach

  -  let spf[n+1] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                     0  1  2  3  4  5  6  7  8  9  10
  - start from (2 - sqrt(n)), and for every multiple of 2, replace it with 2, similar for 3
  - basically, whenever spf[i] > i, replace it with i

  -  replace 2's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 9, 2]
                              0  1  2  3  4  5  6  7  8  9  10
  -  replace 3's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2]
                              0  1  2  3  4  5  6  7  8  9  10
  -  replace 5's multiples = [0, 1, 2, 3, 2, 5, 2, 7, 2, 3, 2]
                              0  1  2  3  4  5  6  7  8  9  10

  - replace only if spf[i] is untouched, to be untouched, spf[i] = i, very initial state of the array
