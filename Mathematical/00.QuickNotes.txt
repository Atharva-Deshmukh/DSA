
---------------------------------------- DMAS ----------------------------------------

Very large numbers are represented in the form of strings
Iterate from last


SUM:  
        Concepts: Carry = (sum / 10)
                  digitToPlace = sum % 10

        sum = String(((d1 + d2) + carry) % 10) + sum;
        carry = Math.floor(((d1 + d2) + carry) / 10);

To Remove any leading zeros: 
          return res.replace(/^0+/, "");

SUBTRACTION:

        Concepts: borrow and isBorrowTaken flag
                  Also, 0 after borrow changes to 9

        if(isBorrowTaken === true) {
            if(d1 === 0) d1 = 9;
            else {
                d1 = d1 - 1;
                isBorrowTaken = false;      // borrow had been consumed
            }
        }
         
        if(d1 < d2) {
            d1 = 10 + d1;
            isBorrowTaken = true;
        }

MULTIPLICATION: (This is little tricky)

                Concepts: Product is to be stored in a single product[]
                          size of product[] <= (n1 + n2)

                          We need to calculate shift
                          We need to two carries viz. productCarry and additionCarry

    // iterate second number from last
    for(let i = (n2-1); i >= 0; i--) {
        
        let productCarry: number = 0;
        let additionCarry: number = 0;
        
        // we are iterating from second number first, second number is multiplied with all digits in first number
        // position of second number's digit = shift basically, 0th index in second number = 0 shift
        const shift: number = (n2-1) - i;
        
        // iterate first number from last
        for(let j = (n1-1); j >= 0; j--) {
            const prod: number = (Number(b[i]) * Number(a[j])) + productCarry;
            const prodDigit: number = prod % 10;
            productCarry = Math.floor(prod / 10);
            
            // now, we will place fill product[] as a single array only
            // currentDigit in product[] after calculating the shift = product[(n1-1-j) + shift]
            
            // n1-1-j instead of direct j since we are filling product[] from start, but j is in reverse order (n1-1 --> 0)
            // to convert reverse order indexing to 0-based ascending indexing we use (n1-1-j)
            // basically, adjustedIndex + shift
            //                 (n1-1-j) + shift
            
            //                           existing digit in product[]  
            const totalProduct: number = product[(n1-1-j) + shift] + prodDigit + additionCarry;
            const digitToPlace: number = totalProduct % 10;
            additionCarry = Math.floor(totalProduct / 10);
            
            // place the digit inside product[] after proper shifting
            product[(n1-1-j) + shift] = digitToPlace;
        }
        
            // if any carry remains, directly attach it at the end 
            // no need to look for type of indexing since we will reverse product[] in the end, 
            // go directly by size, directly attach carries at the end
            product[n1 + shift] = product[n1 + shift] + productCarry + additionCarry;
    }


DIVISION

Approach: School maths for divison
                                                   1 4
                                                   ---
                                               2  )3 8(
                                                   2
                                                   ---
                                                   1 8     --> for (3/2): carry = 1 for next division
                                                     8         hence next num x = (carry * 10) + currDigit
                                                   ---
                                                   0 0


    DRY RUN:

    a = "9999";         b = "11";

    Initial Values:

    res = ""
    carry = 0
    b = 11
    Iterate Over Digits of a:

    1st Digit (9):

    x = carry * 10 + 9 = 0 * 10 + 9 = 9
    Quotient: Math.floor(9 / 11) = 0
    Carry: 9 % 11 = 9
    res = "0"

Approach to memorise:

    if((n1 <= n2) && (BigInt(a) < BigInt(b))) return '0';  // bigint is used since it is known that numbers are large

    let carry: number = 0;
    for(let i = 0; i < n1; i++) {
        let x: number = (carry * 10) + Number(a[i]);
        res = res + Math.floor(x / Number(b));
        carry = (x % Number(b));
    }

-------------------------------------------------- CONCEPTS --------------------------------------------------

POWER EXPONENTIATION TRICK: 

Logic:
- let ans = 1;
- Iterate till currentPower = 0

- if(currentPower === odd) 
  ans = ans * currentBase
  currentPower = currentPower - 1

- if(currentPower === even) 
  currentPower = currentPower / 2
  currentBase = (currentBase * currentBase) = (currentBase ^ 2)
  
TC: O(log2(power)) since we are continuously dividing by 2
SC: O(1)


TRICK TO KNOW IF A NUMBER IS PERFECT SQUARE:

KNOW THAT: sum of odd numbers is a perfect square
For 1,3,5,7,9,11
1 + 3 = 4                      Iterations = 2 = sqrt(4)
1 + 3 + 5 = 9                  Iterations = 3 = sqrt(9)
1 + 3 + 5 + 7 = 16 and so on,

    let odd: number = 1;
    while(n > 0) {
        n -= odd;
        odd +=2;
    }
    return n === 0;

REVERSE NUMBER (with limit of 32 bit):

        const LIMIT = 2 ** 31 - 1;
        const limitDiv10 = Math.floor(LIMIT / 10);

        while (n > 0) {
            const lastDigit = n % 10;

            if (res > limitDiv10 || (res === limitDiv10 && lastDigit > LIMIT % 10)) {
                return 0;
            }

            res = res * 10 + lastDigit;
            n = Math.floor(n / 10);
        }


HCF/GCD:

          function EuclideanGCD(a: number, b: number): number { 
                  if (a === 0) return b; 
                  return EuclideanGCD(b % a, a); 
          }

LCM: 

        function LCM(a: number, b: number): number {
            return Math.floor((a * b) / EuclideanGCD(a,b));
        }


IS PRIME:

      function isPrime(n: number): boolean {
          if(n <= 1) return false;
          for(let i = 2; i <= Math.sqrt(n); i++) {
              if(n % i === 0) return false;
          }
          return true;
      }

SIEVE OF ERASTOTHENIS:
          
          let sieve: number[] = Array(n+1).fill(1);

        // mark the sieve
        for(let i = 2; i <= Math.sqrt(n); i++) {
            if(sieve[i] === 1) {
                for(let j = i * i; j <= n; j+=i) sieve[j] = 0; 
            }
        }

PRIMES IN A RANGE:

    SIEVE --> PREFIX[]

    for(let i = 1; i < sieve.length; i++) {
        prefixSum[i] = prefixSum[i-1] + sieve[i];
    }

    return (prefixSum[R - 1] - prefixSum[L - 1]);

PRIME FACTORS(unique):

      // since after 2, when i += 2, we skip 3, so do a while loop for 2 beforehand
      if(n % 2 === 0) {
          ans.add(2);
          while(n % 2 === 0) n = Math.floor(n/2);
      }

      for(let i = 3; i <= Math.floor(Math.sqrt(n)); i += 2) {
          if(n % i === 0) {
              ans.add(i);
              while(n % i === 0) n = Math.floor(n/i);
          } 
      }

      // case: if n itself is a prime number, we add it in the last after we have exhausted every multiple
      if(n > 2) ans.add(n);

PRIME FACTORS (all) --> JUST USE ARRAY INTEAD OF SET IN ABOVE consumed

SMALLEST PRIME FACTOR:

        function fillSPF() {
            for(let i = 0; i < SPF.length; i++) SPF[i] = i;

            for(let i = 2; i < SPF.length; i++) {

                //if its untouched, then only override the multiples also, 
                // override such that smallest override is there in the array
                
                if(SPF[i] === i) {
                    for(let j = i * i;j < SPF.length; j += i) {
                        if(i <= SPF[j]) SPF[j] = i;
                    }
                }
            }
        }

PRIME FACTORS USING SPF(SMALLES PRIME FACTOR):

          SPF(20) = 2   now 20/2 = 10
          SPF(10) = 2   now 10/2 = 5
          SPF(5) = 5    now 5/5 = 1


              while(n != 1) {
              let factor = SPF[n];
              primeFactors.push(factor);
              n = n / factor;
              }

              return primeFactors;

CALCULATE ALL FACTORS (PRIME and NONPRIME):

        Prime numbers have only two factors (1, n)
        Perfect square have one duplicate factor, say 100 -> 10 is duplicate

        Iterate 1 --> sqrt(n) 
                store (i)

        Iterate sqrt(n) --> 1
                if(i !== Math.floor(sqrt(n)))
                  store (n / i) 


FACTORIAL OF LARGE NUMBERS:

        /* Outer loop iterates n */
        for(let i = 2; i <= n; i++) {
            
            // reset the carry
            carry = 0;

            /* Inner loop iterates the res[] and modifies it */
            for(let j = 0; j < res.length; j++) {
                const currentProduct: number = (i * res[j]);
                const digitToPlace: number = (currentProduct + carry) % 10;
                carry = Math.floor((currentProduct + carry) / 10);

                // place the digit at jth index
                res[j] = digitToPlace;
            }

            // if the carry is remaining, push it at the end
            while(carry > 0) {
                res.push(carry % 10);
                carry = Math.floor(carry / 10);
            }
            
        }

        return res.reverse();
