Stable sorting algorithms preserve the relative order of records with equal keys (values). 
For example, if two elements have the same key, they will appear 
in the same order in the sorted output as they did in the input.

Ex: 
Merge Sort
Bubble Sort
Insertion Sort
Counting Sort
Radix Sort
Bucket Sort (can be stable, depending on the implementation)

REAL LIFE EXAMPLE

You have a list of employees sorted by their department, and you now need to sort them by their salary.
Using a stable sort ensures that employees with the same salary remain in the same order as they were 
based on their department.

Why Stability Matters:

Stability is crucial in multi-level sorting (e.g., sorting on multiple keys or criteria).
If the sorting is unstable, the grouping by the first sort (e.g., department) would be disrupted.

Algorithm Example: Tim Sort
Tim Sort, used in Python (sorted()) and Java (Collections.sort()), is stable. 
It ensures the integrity of multi-level sortings like the one mentioned above.

------------------------------------------------------------------------------------------

Unstable sorting algorithms may change the relative order of records with equal keys during sorting.

Ex: 
Quick Sort (in most implementations)
Heap Sort
Selection Sort
Shell Sort

REAL LIFE EXAMPLE

A search engine needs to sort web pages by relevance score. If two pages have the same score, 
their relative order in the sorted list doesn't matter.

Why Stability Isn't Important:

Performance is more critical than maintaining relative order.
The input size can be huge, and unstable algorithms like Quick Sort or Heap Sort are generally faster
or require less memory.

Quick Sort, being unstable, is often used in applications where the data size is large, and stability 
isn't required. It's efficient due to its divide-and-conquer approach.
