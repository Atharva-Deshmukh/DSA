Stable sorting algorithms preserve the relative order of records with equal keys (values). 
For example, if two elements have the same key, they will appear 
in the same order in the sorted output as they did in the input.

Ex: 
Merge Sort
Bubble Sort
Insertion Sort
Counting Sort
Radix Sort
Bucket Sort (can be stable, depending on the implementation)

REAL LIFE EXAMPLE

You have a list of employees sorted by their department, and you now need to sort them by their salary.
Using a stable sort ensures that employees with the same salary remain in the same order as they were 
based on their department.

Why Stability Matters:

Stability is crucial in multi-level sorting (e.g., sorting on multiple keys or criteria).
If the sorting is unstable, the grouping by the first sort (e.g., department) would be disrupted.

Algorithm Example: Tim Sort
Tim Sort, used in Python (sorted()) and Java (Collections.sort()), is stable. 
It ensures the integrity of multi-level sortings like the one mentioned above.

------------------------------------------------------------------------------------------

Unstable sorting algorithms may change the relative order of records with equal keys during sorting.

Ex: 
Quick Sort (in most implementations)
Heap Sort
Selection Sort
Shell Sort

REAL LIFE EXAMPLE

A search engine needs to sort web pages by relevance score. If two pages have the same score, 
their relative order in the sorted list doesn't matter.

Why Stability Isn't Important:

Performance is more critical than maintaining relative order.
The input size can be huge, and unstable algorithms like Quick Sort or Heap Sort are generally faster
or require less memory.

Quick Sort, being unstable, is often used in applications where the data size is large, and stability 
isn't required. It's efficient due to its divide-and-conquer approach.

Can we make any sorting algorithm stable? 
Yes, any sorting algorithm can be made stable, but it might come at the cost of additional time or 
space complexity.

Steps to implement above:
Pair each element with its original position.
Transform the input array into pairs like (value, original_index). Example: Input [3, 1, 3] 
becomes [(3, 0), (1, 1), (3, 2)].

Sort the array.
Use the algorithm of choice, ensuring it considers the original index as a tie-breaker.

Primary key: value
Secondary key: original_index
Extract the sorted values.
Remove the auxiliary information once the sorting is complete.
